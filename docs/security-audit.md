# Security Audit: ReMemory

> **This audit is AI-assisted.** It was generated by Claude (Opus 4.6) to provide a structured, reproducible evaluation of the ReMemory codebase. Every finding is backed by a command you can run or a code path you can read yourself. The AI's role is directing attention to the right places; your terminal is the source of truth.

**Audit date:** 2026-02-11
**Commit:** [`5f464d1`](https://github.com/eljojo/rememory/blob/5f464d1/go.mod) (new-security-report branch)
**Go version:** 1.25.7
**Intended audience:** Security professionals and security-conscious users evaluating whether to trust this software

---

## Table of Contents

1. [Is This Software Safe to Install and Run?](#1-is-this-software-safe-to-install-and-run)
2. [Is This Software Secure for Its Purpose?](#2-is-this-software-secure-for-its-purpose)
3. [Threat Model](#3-threat-model)
4. [Deep Dives](#4-deep-dives)
5. [Where a Professional Reviewer Should Focus](#5-where-a-professional-reviewer-should-focus)
6. [What This Audit Did Not Cover](#6-what-this-audit-did-not-cover)

---

### Confidence Labels

Each finding ends with a confidence label indicating the type of evidence behind it:

- **Tool output** — produced by running a specific command. You can reproduce it yourself.
- **Code pointer** — based on reading the source code. The relevant file and line are cited so you can verify.
- **Structural observation** — follows from the architecture or design, not a single line of code. Requires understanding the system as a whole.

These are honest about what the AI can and can't verify. Tool output is the strongest claim. Code pointers and structural observations require human judgment to confirm.

---

## 1. Is This Software Safe to Install and Run?

### 1.1 Dependency Vulnerability Scanning

#### govulncheck (Go's official vulnerability database)

```bash
nix shell nixpkgs#govulncheck -c govulncheck -show verbose ./...
```

**What it checks:** Scans your Go code and dependencies against the official Go vulnerability database. Only reports vulnerabilities in functions your code actually calls.

**Output at time of audit:**

```
=== Symbol Results ===
No vulnerabilities found.
```

govulncheck scanned 14 modules and the go1.25.7 standard library. Zero vulnerabilities — in called code, imported packages, or required modules.

**Confidence:** Tool output — run it yourself to verify.

#### gosec (Go security static analysis)

```bash
nix shell nixpkgs#gosec -c gosec -quiet ./...
```

**What it checks:** Static analysis for common Go security issues (hardcoded credentials, path traversal, file permissions, integer overflow, etc.)

**Output at time of audit:** 24 findings across 3 severity levels.

**HIGH severity (2 findings) — integer overflow in tar file mode conversion:**

Both are `os.FileMode(header.Mode)` conversions (int64 to uint32) at [`internal/manifest/archive.go:189`](https://github.com/eljojo/rememory/blob/5f464d1/internal/manifest/archive.go#L189) and [`archive.go:207`](https://github.com/eljojo/rememory/blob/5f464d1/internal/manifest/archive.go#L207). The code masks with `&0777` and `&0666` respectively, clamping the value to valid permission bits. In practice, tar file modes are small positive integers. The archives are self-generated by the tool.

**MEDIUM severity (20 findings):**

| Category | Count | Assessment |
|----------|-------|------------|
| G304 — File inclusion via variable | 8 | Expected: CLI reads user-specified paths. Not a vulnerability. |
| G301 — Directory permissions 0755 | 6 | Standard for directories. Shares (sensitive) use 0600. |
| G306 — File permissions 0644 | 3 | Applies to MANIFEST.age, project.yml, HTML output. See [Section 4.1](#41-passphrase-lifecycle) for discussion. |
| G305 — Tar path traversal | 1 | Flagged at `archive.go:180`, but the code has a traversal check at line 183. False positive. |
| G101 — Hardcoded credentials | 2 | Both in `demo.go` — intentional demo placeholder text. |

**Confidence:** Tool output — run it yourself.

#### syft + grype (SBOM generation + vulnerability scanning)

```bash
nix shell nixpkgs#syft nixpkgs#grype -c sh -c 'syft dir:. -o cyclonedx-json | grype'
```

**What it checks:** Generates a Software Bill of Materials (SBOM), then scans all identified packages against multiple vulnerability databases (NVD, GitHub Advisories, etc.)

**Output at time of audit:**

```
No vulnerabilities found
```

Zero vulnerabilities across all dependencies and the Go 1.25.7 standard library.

**Confidence:** Tool output.

#### go vet + go mod verify

```bash
go vet ./...       # Static analysis from Go toolchain
go mod verify      # Verify dependency checksums
```

**Output at time of audit:**

- `go vet`: Clean — no issues found.
- `go mod verify`: `all modules verified` — every dependency matches its recorded checksum in `go.sum`.

**Confidence:** Tool output.

### 1.2 Dependency Surface

```bash
# Direct dependencies (go.mod)
go list -m all | head -1   # ReMemory itself
go list -m -json all | grep -c '"Indirect": true'  # Count indirect
```

**Direct dependencies (7):**

| Dependency | Version | Purpose | Touches sensitive data? |
|------------|---------|---------|----------------------|
| [`filippo.io/age`](https://github.com/FiloSottile/age) | v1.3.1 | Encryption (scrypt + ChaCha20-Poly1305) | Yes — encrypts/decrypts manifest |
| [`github.com/hashicorp/vault`](https://github.com/hashicorp/vault) | v1.21.2 | Shamir's Secret Sharing (shamir subpackage only) | Yes — splits/combines passphrase |
| [`golang.org/x/text`](https://pkg.go.dev/golang.org/x/text) | v0.33.0 | Unicode normalization for BIP39 words | Yes — word decoding touches share data |
| [`github.com/go-pdf/fpdf`](https://github.com/go-pdf/fpdf) | v0.9.0 | PDF generation for bundle README | Renders share words into PDF |
| [`github.com/skip2/go-qrcode`](https://github.com/skip2/go-qrcode) | v0.0.0-20200617 | QR code generation for PDF | Encodes compact share into QR |
| [`github.com/spf13/cobra`](https://github.com/spf13/cobra) | v1.10.2 | CLI framework | No |
| [`gopkg.in/yaml.v3`](https://pkg.go.dev/gopkg.in/yaml.v3) | v3.0.1 | YAML parsing for project.yml | Reads project config |

**Indirect dependencies (8):** `filippo.io/hpke`, `go-md2man`, `mousetrap`, `blackfriday`, `pflag`, `go.yaml.in/yaml/v3`, `golang.org/x/crypto`, `golang.org/x/sys`

**Total modules in dependency graph:** ~559 (the large count is due to `hashicorp/vault` pulling in its full module graph, though only the `shamir` subpackage is imported).

**Key observation:** The dependency tree is dominated by HashiCorp Vault's module graph. Only the `shamir` subpackage is imported:

```bash
grep -r "hashicorp/vault" --include="*.go" . | grep -v _test.go | grep -v vendor
# Expected: only internal/core/shamir.go importing "github.com/hashicorp/vault/shamir"
```

The `go.sum` file contains only 34 lines (17 modules with their go.mod hashes) — the actual compiled dependency footprint is small despite the large module graph.

**Confidence:** Tool output + code pointer.

### 1.3 No Network Calls

```bash
# Check all Go imports for networking packages
go list -f '{{.ImportPath}}: {{.Imports}}' ./cmd/... ./internal/... 2>/dev/null | grep -E "net/http|net\""

# Expected: empty output
```

The CLI makes zero network requests. Verify:

```bash
# No os/exec usage (no shelling out)
grep -rn "os/exec" --include="*.go" . | grep -v _test.go
# Expected: no matches

# No telemetry or analytics
grep -ri "telemetry\|analytics\|tracking\|sentry\|datadog" --include="*.go" --include="*.js" . --exclude-dir=node_modules
# Expected: no matches

# No math/rand (only crypto/rand for randomness)
grep -rn "math/rand" --include="*.go" . | grep -v _test.go
# Expected: no matches
```

**Confidence:** Tool output — run these yourself.

### 1.4 No Network in Recovery Tool

The browser-based `recover.html` is self-contained:

```bash
# Check for external script loading
grep -E "<script.*src=" internal/html/assets/recover.html
# Expected: no matches

# Check for fetch/XHR calls in compiled JS
grep -n "fetch\|XMLHttpRequest\|sendBeacon" internal/html/assets/app.js
# Expected: one match — fetch('recover.wasm') — a relative path fallback
```

WASM is gzip-compressed and base64-encoded inline. The only `fetch` call is a local fallback for `recover.wasm` that fails silently when running from `file://` and uses the embedded binary instead. See [`internal/html/assets/src/shared.ts`](https://github.com/eljojo/rememory/blob/5f464d1/internal/html/assets/src/shared.ts) for the WASM loading logic.

**Content Security Policy:** Both `recover.html` and `maker.html` include a strict CSP via `<meta>` tag:

```
Content-Security-Policy:
  default-src 'none';
  script-src 'nonce-{{CSP_NONCE}}' 'wasm-unsafe-eval';
  style-src 'unsafe-inline';
  img-src blob: data:;
  connect-src blob:;
  form-action 'none';
```

Each generated HTML file gets a unique 128-bit random nonce via [`internal/html/csp.go`](https://github.com/eljojo/rememory/blob/5f464d1/internal/html/csp.go). Scripts without the correct nonce are blocked by the browser. `default-src 'none'` blocks all resource loading by default. `form-action 'none'` prevents form-based data exfiltration. `connect-src blob:` allows only blob URLs (used for file downloads), not external connections.

**Code pointer:** CSP nonce generation at [`csp.go:10-16`](https://github.com/eljojo/rememory/blob/5f464d1/internal/html/csp.go#L10-L16), applied at [`recover.go:74-75`](https://github.com/eljojo/rememory/blob/5f464d1/internal/html/recover.go#L74-L75) and [`create.go:38-39`](https://github.com/eljojo/rememory/blob/5f464d1/internal/html/create.go#L38-L39).

**Confidence:** Tool output + code pointer.

### 1.5 WASM Import Inspection

You can verify that the WASM binary doesn't import unexpected host functions:

```bash
# Build recover.wasm and inspect its imports
make wasm
nix shell nixpkgs#wabt -c wasm-objdump -x internal/html/assets/recover.wasm -j Import
```

Expected: only Go runtime imports (`gojs` namespace — `syscall/js` bridge functions like `valueGet`, `valueSet`, `valueCall`). No `fetch`, `XMLHttpRequest`, or Web API imports.

**WASM file sizes at time of audit:**
- `recover.wasm`: 6.0 MB (recovery-only, embedded in each friend's `recover.html`)
- `create.wasm`: 18.2 MB (full creation + recovery, used by `maker.html`)

**Confidence:** Tool output.

### 1.6 Ongoing Dependency Monitoring

Dependabot is enabled on this repository ([`.github/dependabot.yml`](https://github.com/eljojo/rememory/blob/5f464d1/.github/dependabot.yml)) with weekly checks for:

- **Go modules** (`gomod`) — catches vulnerable dependencies
- **GitHub Actions** — catches compromised CI actions
- **npm** — catches vulnerable Playwright/dev dependencies

This provides continuous monitoring between point-in-time audits. Dependabot will automatically open PRs when vulnerabilities are detected in any of these ecosystems.

**Confidence:** Code pointer.

---

## 2. Is This Software Secure for Its Purpose?

This section covers the cryptographic composition and whether the Shamir/age construction holds. Tools reach their limit here — the real assurance comes from reading code.

### 2.1 Cryptographic Composition

The design composes two well-established primitives:

1. **age** (scrypt mode) encrypts the manifest with a random passphrase
2. **Shamir's Secret Sharing** (HashiCorp Vault) splits the passphrase into shares

The composition is sound if:
- The passphrase has sufficient entropy (it does: 256 bits from `crypto/rand`)
- The Shamir split operates on the raw passphrase bytes (it does in v2)
- Below-threshold shares reveal zero information about the passphrase (guaranteed by Shamir's information-theoretic security)
- Share metadata doesn't leak information that weakens the guarantee (it doesn't — see [Section 4.2](#42-share-format-and-metadata-leakage))

### 2.2 What the Code Does (High-Level)

**Sealing (creation):**
1. Archive `manifest/` directory into tar.gz (in memory)
2. Generate 32 random bytes via `crypto/rand` → base64url encode → passphrase
3. Encrypt tar.gz with age (scrypt mode, passphrase)
4. Split raw 32 bytes via Shamir into N shares with threshold K
5. Verify reconstruction: combine K shares, re-derive passphrase, compare
6. Write MANIFEST.age (encrypted), share files (0600), ZIP bundles

**Recovery (reconstruction):**
1. Parse share files, verify checksums
2. Validate compatibility (version, total, threshold must match)
3. Check threshold met, no duplicate indices
4. Combine shares via Shamir → recover raw bytes → base64url encode → passphrase
5. Decrypt MANIFEST.age with recovered passphrase
6. Extract tar.gz to output directory

**Code pointers:**
- Seal: [`internal/cmd/seal.go:82-250`](https://github.com/eljojo/rememory/blob/5f464d1/internal/cmd/seal.go#L82-L250)
- Recover: [`internal/cmd/recover.go:44-203`](https://github.com/eljojo/rememory/blob/5f464d1/internal/cmd/recover.go#L44-L203)

**Confidence:** Structural observation — verified by reading the code paths end-to-end.

---

## 3. Threat Model

### 3.1 An attacker who obtains fewer than threshold shares

**Design promise:** Zero information about the passphrase is revealed. This is Shamir's information-theoretic guarantee — it holds regardless of computational power.

**What enforces it:**
- [`internal/core/shamir.go:14-25`](https://github.com/eljojo/rememory/blob/5f464d1/internal/core/shamir.go#L14-L25) — delegates to `github.com/hashicorp/vault/shamir.Split()`, which operates over GF(2^8).
- The share data itself is a Shamir share — a point on a random polynomial. No additional information is embedded in the share data bytes.

**What to verify:** That share metadata doesn't leak information. See [Section 4.2](#42-share-format-and-metadata-leakage).

**Confidence:** Code pointer + structural observation. The information-theoretic guarantee follows from the mathematical properties of Shamir's Secret Sharing, not from the implementation. The implementation's job is to not add leakage, and it doesn't.

### 3.2 An attacker who compromises a single friend's bundle

**Design promise:** A single bundle reveals that friend's share (one point on the polynomial) and the encrypted manifest. Without threshold-1 additional shares, the passphrase cannot be reconstructed and the manifest cannot be decrypted.

**What enforces it:**
- The encrypted manifest uses age with a 256-bit random passphrase. Brute-forcing scrypt with this entropy is computationally infeasible.
- The share gives one Shamir point — information-theoretically insufficient to reconstruct the secret when K >= 2.

**What's in the bundle:**

| File | Contents | Reveals |
|------|----------|---------|
| README.txt / README.pdf | Instructions + share (PEM + words) | The friend's single share + scheme parameters (N, K) |
| MANIFEST.age | age-encrypted archive | Nothing (encrypted with 256-bit passphrase) |
| recover.html | Self-contained recovery tool + personalization | Friend names, contact info, the friend's pre-loaded share |

**Personalization data** embedded in `recover.html` includes friend names and contact info for all friends (unless anonymous mode was used). This is intentional — it helps coordinate recovery. It does not leak cryptographic material.

**Code pointer:** [`internal/bundle/bundle.go`](https://github.com/eljojo/rememory/blob/5f464d1/internal/bundle/bundle.go) for bundle generation, [`internal/html/recover.go`](https://github.com/eljojo/rememory/blob/5f464d1/internal/html/recover.go) for personalization embedding.

**Confidence:** Code pointer + structural observation.

### 3.3 An attacker with access to the creator's machine after sealing

**Design promise:** After sealing, the creator's machine holds the encrypted manifest and all share files. An attacker with full disk access can read everything.

**What this means:**
- The attacker has all N shares → they can reconstruct the passphrase → they can decrypt the manifest. **This is by design.** The seal operation creates shares that are meant to be distributed; until distribution, they're all in one place.
- After distribution, the creator should delete the share files. The project doesn't automate this.

**What remains on disk after sealing:**

| File | Permissions | Contains |
|------|------------|----------|
| `output/MANIFEST.age` | 0644 | Encrypted archive |
| `output/shares/SHARE-*.txt` | 0600 | Individual shares (PEM format) |
| `output/bundles/bundle-*.zip` | 0644 | Complete bundles for each friend |
| `project.yml` | 0644 | Friend names, SHA-256 of passphrase, share checksums |

**Note:** `project.yml` stores `sha256:<hash of passphrase>` as a verification hash. This is a one-way hash of a 256-bit random value — offline brute force is infeasible.

```bash
# Verify share file permissions
grep -n "0600" internal/cmd/seal.go
# Line 155: os.WriteFile(sharePath, []byte(share.Encode()), 0600)
```

**Confidence:** Code pointer.

### 3.4 A malicious or compromised dependency

**Design promise:** The code relies on established cryptographic libraries rather than custom primitives. Dependencies are pinned by `go.sum` checksums.

**What enforces it:**
- `go mod verify` confirms all module checksums match their recorded values.
- Only 2 dependencies touch sensitive data: `filippo.io/age` (encryption) and `github.com/hashicorp/vault/shamir` (secret sharing).
- Both are widely used, maintained, and have existing security audits.
- Dependabot is enabled for weekly vulnerability monitoring of Go modules, GitHub Actions, and npm packages.

**What to verify:**
```bash
# Confirm no tampering
go mod verify
# Expected: "all modules verified"

# Review the full dependency graph
go mod graph | grep "github.com/eljojo/rememory " | sort
```

**Residual risk:** A compromised version of age or vault could exfiltrate secrets. This is mitigated by pinned versions, checksums, and Dependabot monitoring, but not eliminated. govulncheck provides ongoing monitoring for known vulnerabilities.

**Confidence:** Tool output + structural observation.

### 3.5 A friend who acts alone trying to recover the secret

**Design promise:** A single friend cannot recover the secret when threshold >= 2.

**What enforces it:**
- **Creation time:** [`internal/core/shamir.go:46`](https://github.com/eljojo/rememory/blob/5f464d1/internal/core/shamir.go#L46) — threshold must be >= 2.
- **Recovery time (CLI):** [`internal/cmd/recover.go:87-89`](https://github.com/eljojo/rememory/blob/5f464d1/internal/cmd/recover.go#L87-L89) — checks `len(shares) < first.Threshold` before attempting combination.
- **Recovery time (WASM):** [`internal/wasm/recover.go:83-84`](https://github.com/eljojo/rememory/blob/5f464d1/internal/wasm/recover.go#L83-L84) — checks `len(shares) < 2`, and [`recover.go:95-97`](https://github.com/eljojo/rememory/blob/5f464d1/internal/wasm/recover.go#L95-L97) — checks `len(shares) < shares[0].Threshold`.
- **Underlying library:** `vault.Combine()` requires at least 2 shares and produces garbage with fewer than K shares.

The WASM path now validates both the minimum of 2 shares and the specific threshold K. Even without this check, Shamir reconstruction with fewer than K shares produces garbage, and the subsequent age decryption fails with "incorrect passphrase."

```bash
# Verify threshold validation at creation
grep -n "threshold must be at least 2" internal/core/shamir.go
# Line 47

# Verify threshold check at recovery (CLI)
grep -n "Threshold" internal/cmd/recover.go | head -5
# Lines 82-89: validates shares >= threshold

# Verify threshold check at recovery (WASM)
grep -n "Threshold" internal/wasm/recover.go | head -5
# Line 95: validates shares >= threshold
```

**Confidence:** Code pointer.

---

## 4. Deep Dives

### 4.1 Passphrase Lifecycle

**Generation:** [`internal/crypto/passphrase.go:26-39`](https://github.com/eljojo/rememory/blob/5f464d1/internal/crypto/passphrase.go#L26-L39)

```go
raw = make([]byte, numBytes)             // 32 bytes
if _, err := rand.Read(raw); err != nil  // crypto/rand (OS CSPRNG)
passphrase = base64.RawURLEncoding.EncodeToString(raw)  // ~43 chars
```

- Uses `crypto/rand` exclusively — verify: `grep -rn "math/rand" --include="*.go" . | grep -v _test.go` should return no matches.
- 32 bytes = 256 bits of entropy. Minimum enforced at line 28 (>= 16 bytes).

**Usage during seal:** [`internal/cmd/seal.go:112-198`](https://github.com/eljojo/rememory/blob/5f464d1/internal/cmd/seal.go#L112-L198)

1. `raw, passphrase` generated (line 112)
2. `passphrase` used for age encryption (line 122)
3. `raw` bytes split via Shamir (line 141) — v2 splits raw bytes, not the base64 string
4. Reconstruction verified: K shares combined, re-encoded, compared (lines 174-186)
5. `HashString(passphrase)` stored in project.yml (line 198) — SHA-256 hash, not plaintext

**Usage in WASM path:** [`internal/wasm/create.go:171-188`](https://github.com/eljojo/rememory/blob/5f464d1/internal/wasm/create.go#L171-L188)

Same pattern: `GenerateRawPassphrase()` → encrypt → split raw bytes. The passphrase exists in WASM linear memory and JavaScript string memory until the page unloads.

**What the reader should verify:**
- The passphrase is never logged or printed (except with explicit `--passphrase-only` flag at [`recover.go:116-121`](https://github.com/eljojo/rememory/blob/5f464d1/internal/cmd/recover.go#L116-L121)).
- Error messages don't include the passphrase — check all `fmt.Errorf` calls in seal.go and recover.go.
- The passphrase is **not zeroed** from memory after use. This is a known limitation of Go — `runtime.GC()` is non-deterministic and Go doesn't provide `mlock`/`mprotect` wrappers. The passphrase bytes persist in heap until garbage collected. This is standard for Go crypto code (age itself has the same property).

**Confidence:** Code pointer — the reader must read these functions and judge.

### 4.2 Share Format and Metadata Leakage

**PEM format:** [`internal/core/share.go:62-87`](https://github.com/eljojo/rememory/blob/5f464d1/internal/core/share.go#L62-L87)

```
-----BEGIN REMEMORY SHARE-----
Version: 2
Index: 1
Total: 5
Threshold: 3
Holder: Alice
Created: 2026-02-11 15:04
Checksum: sha256:abc123...

<base64 encoded share data>
-----END REMEMORY SHARE-----
```

**Headers and what they reveal:**

| Header | Value | Weakens below-threshold guarantee? |
|--------|-------|-----------------------------------|
| Version | Protocol version (1 or 2) | No — public parameter |
| Index | Share number (1-N) | No — required by Shamir (x-coordinate) |
| Total | N (total shares) | No — public scheme parameter |
| Threshold | K (required shares) | No — public scheme parameter |
| Holder | Friend's name | No — identifies holder, not secret |
| Created | Timestamp | No — operational metadata |
| Checksum | SHA-256 of share data | No — derived from share, not from secret |

**Key observation:** None of these headers are derived from the secret passphrase. The checksum is a hash of the share data (a Shamir point), not of the secret. The Index is the x-coordinate for Shamir interpolation — it's a required public parameter.

**Compact format** (QR codes): [`share.go:217-221`](https://github.com/eljojo/rememory/blob/5f464d1/internal/core/share.go#L217-L221) — `RM2:1:5:3:<base64url>:<4-char checksum>`. Same metadata exposure.

**Word encoding** (BIP39): Word 25 encodes 4 bits of share index + 7 bits of checksum. The checksum is over the share data bytes, not the secret.

**Confidence:** Code pointer — the reader should verify that `HashBytes(data)` at [`share.go:47`](https://github.com/eljojo/rememory/blob/5f464d1/internal/core/share.go#L47) hashes `data` (the Shamir share), not the original secret.

### 4.3 WASM/JS Boundary

**Exposed functions:** [`internal/wasm/main_recover.go`](https://github.com/eljojo/rememory/blob/5f464d1/internal/wasm/main_recover.go) registers 7 functions. [`main_create.go`](https://github.com/eljojo/rememory/blob/5f464d1/internal/wasm/main_create.go) registers those 7 + 2 more (creation).

| Function | Input from JS | Output to JS | Validates? |
|----------|--------------|-------------|-----------|
| `parseShareJS` | string | share object | Argument count; checksum verified in Go |
| `combineSharesJS` | array of share objects | passphrase string | Argument count; version consistency; threshold check |
| `decryptManifestJS` | Uint8Array + string | Uint8Array | Argument count |
| `extractTarGzJS` | Uint8Array | file array | Argument count; path traversal + size limits in core |
| `extractBundleJS` | Uint8Array | share + manifest | Argument count; checksum verified |
| `parseCompactShareJS` | string | share object | Argument count; format + checksum validated |
| `decodeWordsJS` | string array | data + index + checksum | Argument count; checksum validated |

**Data crossing the boundary:**
- Binary data (encrypted manifest, tar.gz archives) transfers as `Uint8Array` using `js.CopyBytesToGo()` and `js.CopyBytesToJS()` — these are memory copies, not shared references.
- Share data transfers as base64-encoded strings.
- The passphrase is returned as a JavaScript string from `combineSharesJS`. It exists in JavaScript memory until the page unloads.

**What the reader should verify:**
- [`js_wrappers.go`](https://github.com/eljojo/rememory/blob/5f464d1/internal/wasm/js_wrappers.go) — All 7 wrapper functions. Input validation happens at argument count, but not input size. `dataLen := jsData.Get("length").Int()` (e.g., line 73) is used directly to allocate Go memory. This is acceptable because the WASM runs in the user's own browser — they're attacking themselves.
- The extraction path through `extractTarGzJS` delegates to `core.ExtractTarGz()` which enforces path traversal checks, file type filtering, and size limits.

**Confidence:** Code pointer — the reader should read `js_wrappers.go` (~240 lines) and assess whether the data crossing the boundary is handled correctly.

### 4.4 Tar Extraction Security

Two extraction paths exist, both with security checks:

**In-memory (CLI + WASM):** [`internal/core/archive.go:33-93`](https://github.com/eljojo/rememory/blob/5f464d1/internal/core/archive.go#L33-L93)

| Defense | Line | Mechanism |
|---------|------|-----------|
| Path traversal | 44-59 | Regex rejects `..` path components |
| Non-regular files | 62-64 | Only `tar.TypeReg` extracted; directories, symlinks, devices skipped |
| Per-file size limit | 67-68 | 100 MB maximum (`MaxFileSize`) |
| Total size limit | 70-73 | 1 GB maximum (`MaxTotalSize`) |
| LimitReader safety | 76 | Double-checked with `io.LimitReader` |

**File-based (CLI recover):** [`internal/manifest/archive.go:143-247`](https://github.com/eljojo/rememory/blob/5f464d1/internal/manifest/archive.go#L143-L247)

| Defense | Line | Mechanism |
|---------|------|-----------|
| Path traversal | 180-185 | `filepath.Clean(target)` must have `filepath.Clean(destDir)` as prefix |
| Symlinks | 226-228 | Skipped with warning |
| Hard links | 230-232 | Skipped with warning |
| Per-file size limit | 195-196 | Same 100 MB maximum |
| Total size limit | 198-200 | Same 1 GB maximum |
| LimitReader safety | 213 | `io.LimitReader` + post-copy size check at line 222 |
| Permission masking | 189, 207 | Directory modes masked with `&0777`, file modes masked with `&0666` |
| Close error handling | 215-221 | File close errors properly checked and propagated |

**WASM archive creation:** [`internal/wasm/create.go:351-409`](https://github.com/eljojo/rememory/blob/5f464d1/internal/wasm/create.go#L351-L409) receives filenames from JavaScript. It strips leading slashes (line 373) and rejects `..` in paths (line 375-377). Extraction is protected on both paths.

**What the reader should verify:**
- The regex at `archive.go:45` — confirm it catches all traversal patterns (`../`, `foo/../bar`, etc.)
- The `filepath.Clean` + prefix check at `archive.go:183` — confirm it's robust against path canonicalization tricks
- That symlinks in the archive don't create escape paths

**Confidence:** Code pointer.

### 4.5 Threshold Validation

**At creation:** [`internal/core/shamir.go:44-56`](https://github.com/eljojo/rememory/blob/5f464d1/internal/core/shamir.go#L44-L56)
- K >= 2 (line 46)
- K <= N (line 49)
- N <= 255 (line 52)

**At CLI recovery:** [`internal/cmd/recover.go:68-98`](https://github.com/eljojo/rememory/blob/5f464d1/internal/cmd/recover.go#L68-L98)
- Version consistency checked (lines 74-84)
- Total and threshold consistency checked (lines 79-83)
- `len(shares) >= threshold` checked (lines 87-89)
- Duplicate indices rejected (lines 92-98)

**At WASM recovery:** [`internal/wasm/recover.go:82-97`](https://github.com/eljojo/rememory/blob/5f464d1/internal/wasm/recover.go#L82-L97)
- Minimum 2 shares (line 83)
- Version consistency checked (lines 88-92)
- `len(shares) >= threshold` checked (lines 95-97) — added since the first audit

**At WASM creation:** [`internal/wasm/create.go:146-153`](https://github.com/eljojo/rememory/blob/5f464d1/internal/wasm/create.go#L146-L153)
- Minimum 2 friends (line 146)
- Threshold >= 2 (line 149)
- Threshold <= number of friends (line 151)

**Confidence:** Code pointer.

### 4.6 Dependency Deep-Dive: What Touches Sensitive Data

Only three code paths handle the actual secret (passphrase):

1. **`crypto/rand`** (Go stdlib) — generates the 32 random bytes
2. **`filippo.io/age`** (v1.3.1) — encrypts/decrypts the manifest with the passphrase via scrypt
3. **`github.com/hashicorp/vault/shamir`** (v1.21.2) — splits/combines the raw passphrase bytes

```bash
# Trace what imports touch the passphrase
grep -rn "crypto.GenerateRawPassphrase\|core.Encrypt\|core.Decrypt\|core.Split\|core.Combine" --include="*.go" . | grep -v _test.go
```

**age (v1.3.1):** Created by Filippo Valsorda (former Go security lead). Has a [formal specification](https://github.com/C2SP/C2SP/blob/main/age.md). Uses scrypt for key derivation from passphrase, ChaCha20-Poly1305 for encryption. The library has been [audited](https://github.com/FiloSottile/age/tree/main/doc) and is widely used.

**vault/shamir:** Part of HashiCorp Vault, an enterprise secrets management tool. The `shamir` subpackage implements Shamir's Secret Sharing over GF(2^8). This is battle-tested code used in production by thousands of organizations.

**Confidence:** Structural observation.

### 4.7 XSS and HTML Injection

**Server-side HTML generation:** [`internal/html/recover.go:41-78`](https://github.com/eljojo/rememory/blob/5f464d1/internal/html/recover.go#L41-L78)

Personalization data (friend names, contact info, share content) is embedded in `recover.html` via `json.Marshal()` at line 67. Go's `json.Marshal` HTML-escapes `<`, `>`, `&` by default (as `\u003c`, `\u003e`, `\u0026`), preventing `</script>` injection.

**Client-side rendering:** [`internal/html/assets/src/shared.ts:10-15`](https://github.com/eljojo/rememory/blob/5f464d1/internal/html/assets/src/shared.ts#L10-L15)

```typescript
export function escapeHtml(str: string | null | undefined): string {
  if (str == null) return '';
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}
```

User-controlled strings (friend names, error messages) are escaped via `escapeHtml()` before insertion into innerHTML. The toast notification system at [`shared.ts:78-143`](https://github.com/eljojo/rememory/blob/5f464d1/internal/html/assets/src/shared.ts#L78-L143) consistently uses `escapeHtml()` for all dynamic content.

**CSP as defense-in-depth:** Even if an XSS vector were found, the nonce-based CSP would prevent execution of injected scripts that don't carry the correct nonce.

**What the reader should verify:** Search for `innerHTML` assignments in `app.ts` that don't use `escapeHtml()`. The CSP is a safety net, but proper escaping is the primary defense.

**Confidence:** Code pointer.

---

## 5. Where a Professional Reviewer Should Focus

Ranked by risk and time-to-review:

### Priority 1: Cryptographic Core (2-3 hours)

| File | Lines | Why |
|------|-------|-----|
| [`internal/crypto/passphrase.go`](https://github.com/eljojo/rememory/blob/5f464d1/internal/crypto/passphrase.go) | 40 | Passphrase generation — entropy source, byte count, encoding |
| [`internal/core/shamir.go`](https://github.com/eljojo/rememory/blob/5f464d1/internal/core/shamir.go) | 57 | Shamir wrapper — parameter validation, delegation to vault |
| [`internal/core/age.go`](https://github.com/eljojo/rememory/blob/5f464d1/internal/core/age.go) | 86 | age wrapper — empty passphrase check, scrypt mode usage |
| [`internal/core/share.go`](https://github.com/eljojo/rememory/blob/5f464d1/internal/core/share.go) | 329 | Share format — metadata in headers, encoding/decoding, checksum |
| [`internal/cmd/seal.go:82-250`](https://github.com/eljojo/rememory/blob/5f464d1/internal/cmd/seal.go#L82-L250) | 168 | Seal flow — passphrase handling, split, verify, write |
| [`internal/cmd/recover.go:44-203`](https://github.com/eljojo/rememory/blob/5f464d1/internal/cmd/recover.go#L44-L203) | 160 | Recover flow — combine, decrypt, extract |

**What to look for:** Passphrase leakage in error paths, correct delegation to libraries, parameter validation completeness.

### Priority 2: WASM/JS Boundary (1-2 hours)

| File | Lines | Why |
|------|-------|-----|
| [`internal/wasm/js_wrappers.go`](https://github.com/eljojo/rememory/blob/5f464d1/internal/wasm/js_wrappers.go) | 240 | Bridge between JS and Go — all data crossing the boundary |
| [`internal/wasm/recover.go`](https://github.com/eljojo/rememory/blob/5f464d1/internal/wasm/recover.go) | ~198 | WASM-side recovery logic — share parsing, combining, decryption |
| [`internal/wasm/create.go`](https://github.com/eljojo/rememory/blob/5f464d1/internal/wasm/create.go) | ~509 | WASM-side creation — archive building, friend name handling |

**What to look for:** Input validation gaps, data leakage through error messages, memory handling across the boundary.

### Priority 3: Archive Handling (1 hour)

| File | Lines | Why |
|------|-------|-----|
| [`internal/core/archive.go`](https://github.com/eljojo/rememory/blob/5f464d1/internal/core/archive.go) | 94 | In-memory tar.gz extraction with security checks |
| [`internal/manifest/archive.go`](https://github.com/eljojo/rememory/blob/5f464d1/internal/manifest/archive.go) | 296 | File-based tar.gz archive and extract |

**What to look for:** Path traversal bypasses, symlink handling completeness, size limit enforcement.

### Priority 4: HTML Generation and CSP (1 hour)

| File | Lines | Why |
|------|-------|-----|
| [`internal/html/recover.go`](https://github.com/eljojo/rememory/blob/5f464d1/internal/html/recover.go) | ~96 | Personalization embedding — `json.Marshal` into `<script>` tag |
| [`internal/html/csp.go`](https://github.com/eljojo/rememory/blob/5f464d1/internal/html/csp.go) | 23 | CSP nonce generation — entropy source, application |
| [`internal/html/assets/src/app.ts`](https://github.com/eljojo/rememory/blob/5f464d1/internal/html/assets/src/app.ts) | ~1300 | Client-side recovery logic — DOM manipulation, file handling |
| [`internal/html/assets/src/shared.ts`](https://github.com/eljojo/rememory/blob/5f464d1/internal/html/assets/src/shared.ts) | ~234 | Shared utilities — `escapeHtml()`, toast system |

**What to look for:** XSS vectors in HTML generation, proper escaping of user-controlled data (friend names, contact info), innerHTML usage patterns without escapeHtml(). Verify the CSP nonce is applied to all script tags and that no inline event handlers exist.

### Priority 5: Bundle Generation (30 min)

| File | Lines | Why |
|------|-------|-----|
| [`internal/bundle/bundle.go`](https://github.com/eljojo/rememory/blob/5f464d1/internal/bundle/bundle.go) | ~345 | ZIP creation, filename sanitization, manifest embedding |
| [`internal/html/extract.go`](https://github.com/eljojo/rememory/blob/5f464d1/internal/html/extract.go) | 51 | Manifest extraction from personalized HTML (regex parsing) |

**What to look for:** What goes into each bundle, whether anything extra is accidentally included. The regex-based HTML extraction at `extract.go:20` — verify it can't be confused by crafted HTML.

---

## 6. What This Audit Did Not Cover

For full transparency:

- **Cryptographic correctness of age and vault/shamir.** These libraries are treated as trusted primitives. Their security properties are assumed from their specifications, audits, and track records — not verified here.
- **Side-channel attacks** beyond timing (power analysis, EM emissions, cache timing). Go's `crypto/subtle.ConstantTimeCompare` is used for hash verification ([`internal/core/hash.go:24`](https://github.com/eljojo/rememory/blob/5f464d1/internal/core/hash.go#L24)), but memory-resident passphrases could theoretically be extracted via side channels.
- **Memory safety of the Go runtime and WASM environment.** Go is memory-safe by design; WASM runs in a browser sandbox.
- **Supply chain attacks beyond checksum verification.** `go.sum` ensures integrity against the Go module proxy, but doesn't protect against a compromised upstream repository at the time of initial pinning.
- **Browser-specific attacks** (extensions, compromised browsers, shared machines). The recovery tool runs in whatever browser the user opens it in — it inherits that browser's security posture.
- **Physical security** (secure erasure of printed shares, bundle USB drives, etc.)
- **Formal verification** of the Shamir/age composition.

---

## Appendix A: Verification Commands

Run these from the repository root at commit `5f464d1`:

```bash
# 1. No vulnerabilities in called code
nix shell nixpkgs#govulncheck -c govulncheck ./...

# 2. Static security analysis
nix shell nixpkgs#gosec -c gosec -quiet ./...

# 3. Standard Go static analysis
go vet ./...

# 4. Dependency integrity
go mod verify

# 5. SBOM + vulnerability scan
nix shell nixpkgs#syft nixpkgs#grype -c sh -c 'syft dir:. -o cyclonedx-json | grype'

# 6. No network imports
go list -f '{{.ImportPath}}: {{.Imports}}' ./internal/... 2>/dev/null | grep -E "net/http|net\""

# 7. No os/exec
grep -rn "os/exec" --include="*.go" . | grep -v _test.go

# 8. No telemetry
grep -ri "telemetry\|analytics\|tracking" --include="*.go" --include="*.js" . --exclude-dir=node_modules

# 9. Passphrase entropy source
grep -n "crypto/rand" internal/crypto/passphrase.go

# 10. Passphrase entropy size
grep -n "DefaultPassphraseBytes" internal/crypto/passphrase.go

# 11. Constant-time hash comparison
grep -n "ConstantTimeCompare" internal/core/hash.go

# 12. Share file permissions
grep -n "0600" internal/cmd/seal.go

# 13. Path traversal protection (in-memory)
grep -n "\\.\\." internal/core/archive.go

# 14. Path traversal protection (file-based)
grep -n "HasPrefix" internal/manifest/archive.go

# 15. Threshold minimum enforced
grep -n "threshold must be at least 2" internal/core/shamir.go

# 16. Symlinks rejected
grep -n "Symlink" internal/manifest/archive.go internal/core/archive.go

# 17. CSP nonce generation
grep -n "crypto/rand" internal/html/csp.go

# 18. No inline JS without nonce
grep -n "CSP_NONCE" internal/html/assets/recover.html internal/html/assets/maker.html

# 19. XSS escaping in JS
grep -n "escapeHtml" internal/html/assets/src/shared.ts

# 20. Run the test suite
make test
```

---

## Appendix B: Changes Since Previous Audit

This audit updates the previous audit at commit `8794350`. Key changes in the codebase since then:

| Change | Commit | Impact |
|--------|--------|--------|
| CSP added to recover.html and maker.html | `0cf3977` | XSS defense-in-depth via nonce-based script restriction |
| Threshold validation added to WASM recovery path | `c7abaed` | WASM now checks `len(shares) >= threshold`, not just `>= 2` |
| Path traversal check added to WASM archive creation | `c7abaed` | `create.go` now rejects `..` in filenames from JavaScript |
| Permission masking on tar extraction | `c7abaed` | Directory modes masked with `&0777`, file modes with `&0666` |
| Close error handling improved | `c7abaed` | `rc.Close()` errors now checked in zip/tar extraction |
| Gzip error handling improved | `c7abaed` | `gzip.Write()` and `gzip.Close()` errors now caught in `recover.go` |
| Dependabot enabled | `1dc0167` | Weekly vulnerability monitoring for Go, GitHub Actions, and npm |
| Go updated to 1.25.7 | `5f464d1` | Resolves all previously-flagged stdlib CVEs |

The previous audit found zero critical vulnerabilities and recommended several hardening measures. All recommendations have been implemented.

---

## Appendix C: References

- [age encryption — GitHub](https://github.com/FiloSottile/age)
- [age specification (C2SP)](https://github.com/C2SP/C2SP/blob/main/age.md)
- [HashiCorp Vault shamir package](https://pkg.go.dev/github.com/hashicorp/vault/shamir)
- [Shamir's Secret Sharing — Wikipedia](https://en.wikipedia.org/wiki/Shamir%27s_secret_sharing)
- [govulncheck — Go vulnerability scanner](https://pkg.go.dev/golang.org/x/vuln/cmd/govulncheck)
- [gosec — Go security static analysis](https://github.com/securego/gosec)
- [syft — SBOM generator](https://github.com/anchore/syft)
- [grype — vulnerability scanner](https://github.com/anchore/grype)

---

*This is a point-in-time artifact auditing commit [`5f464d1`](https://github.com/eljojo/rememory/tree/5f464d1). Code links use this commit hash for permanence. For mission-critical use, this document is a starting point — not a substitute for a professional security engagement.*
